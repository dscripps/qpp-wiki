All of the examples of this section are copied verbatim from the
directory [`qpp/examples`](https://github.com/vsoftco/qpp/tree/master/examples) 
and are fully compilable. For convenience, the
location of the source file is displayed in the first line of each
example as a C++ comment. The examples are simple and demonstrate the
main features of [Quantum++](https://github.com/vsoftco/qpp). They cover
only a small part of library functions, but enough to get the interested
user started. For an extensive reference of all library functions,
including various overloads, the user should consult the [official
API documentation](https://github.com/vsoftco/qpp/blob/master/doc/refman.pdf) `qpp/doc/refman.pdf`. 
Additional examples (not
discussed in this document) are located in [`qpp/examples/](https://github.com/vsoftco/qpp/tree/master/examples).

Gates and states
----------------
Let us introduce the main objects used by
[Quantum++](https://github.com/vsoftco/qpp): gates, states and basic
operations. Consider the example 
[qpp/examples/gates_states.cpp](https://github.com/vsoftco/qpp/blob/master/examples/gates_states.cpp) 
with content listed below.

```CPP
// Gates and states
// Source: ./examples/gates_states.cpp
#include <iostream>

#include "qpp.h"

int main() {
    using namespace qpp;
    ket psi = st.z0; // |0> state
    cmat U = gt.X;
    ket result = U * psi;

    std::cout << ">> The result of applying the bit-flip gate X on |0> is:\n";
    std::cout << disp(result) << '\n';

    psi = 10_q;  // |10> state
    U = gt.CNOT; // Controlled-NOT
    result = U * psi;

    std::cout << ">> The result of applying the gate CNOT on |10> is:\n";
    std::cout << disp(result) << '\n';

    U = randU();
    std::cout << ">> Generating a random one-qubit gate U:\n";
    std::cout << disp(U) << '\n';

    result = applyCTRL(psi, U, {0}, {1}); // Controlled-U
    std::cout << ">> The result of applying the CTRL-U gate on |10> is:\n";
    std::cout << disp(result) << '\n';
}
```

A possible output is:

```text
>> The result of applying the bit-flip gate X on |0> is:
0
1
>> The result of applying the gate CNOT on |10> is:
0
0
0
1
>> Generating a random one-qubit gate U:
-0.50206 + 0.0354176i  -0.422949 - 0.753522i
-0.206807 - 0.838995i  -0.390495 + 0.317541i
>> The result of applying the CTRL-U gate on |10> is:
                   0
                   0
-0.50206 + 0.0354176i
-0.206807 - 0.838995i
```

In the line 

```CPP
using namespace qpp;
```

we bring the namespace `qpp` into the
global namespace. In the line 

```CPP
ket psi = st.z0; // |0> state
```

we use the `States` singleton `st` to declare `psi` as the
zero eigenvector |0> of the $Z$ Pauli operator. In the line

```CPP
cmat U = gt.X;
```

we use the `Gates` singleton `gt` and assign to `U` the bit flip gate
`gt.X`. In the next line 

```CPP
ket result = U * psi;
```

we compute the result of the operation $X|0\rangle$,
and display the result $|1\rangle$ in the lines

```CPP
std::cout << ">> The result of applying the bit-flip gate X on |0> is:\n";
std::cout << disp(result) << '\n';
```

Above we used
the display manipulator `disp()`, which is especially useful when
displaying complex matrices, as it displays the entries of the latter in
the form $a+bi$, in contrast to the form $(a,b)$ used by the C++
standard library. The manipulator also accepts additional parameters
that allows e.g. setting to zero numbers smaller than some given value
(useful to chop small values), and it is in addition overloaded for
standard containers, iterators and C-style arrays.

In the line

```CPP
psi = 10_q;  // |10> state
```

we reassign to `psi` the state $|10\rangle$ constructed via the user-defined 
literal `ket operator"" _q()` which transforms a strings of zero and ones to
the corresponding multi-qubit ket (in the computational basis). We could have also used the [Eigen
3](http://eigen.tuxfamily.org/) insertion operator

```CPP
ket psi(4); // must specify the dimension before insertion of elements via <<
psi << 0, 0, 1, 0;
```

or the [Quantum++](https://github.com/vsoftco/qpp) `mket()` function. In the next line

```CPP
U = gt.CNOT; // Controlled-NOT
```

we re-assign to the gate `U`
the Controlled-NOT with control as the first subsystem, and
target as the last, using the global singleton `gt`. In the next line 

```CPP
result = U * psi;	
```

we declare the ket `result` as the result of applying the Controlled-NOT
gate to the state |10>, i.e. |11>. In the next two lines 

```CPP
std::cout << ">> Generating a random one-qubit gate U:\n";
std::cout << disp(U) << '\n';
```

we then display the
result of the computation. Next, in the line 

```CPP
U = randU();
```

we generate a random unitary gate via the function
`randU()`, then in the line 

```CPP
result = applyCTRL(psi, U, {0}, {1}); // Controlled-U
```

we apply the Controlled-U, with control as the
first qubit and target as the second qubit, to the state `psi`. Finally,
we display the result in the last two lines.

Measurements
------------

Let us now complicate things a bit and introduce measurements. Consider
the example [`qpp/examples/measurements.cpp`](https://github.com/vsoftco/qpp/blob/master/examples/measurements.cpp) displayed below.

```CPP
// Measurements
// Source: ./examples/measurements.cpp
#include <iostream>
#include <tuple>

#include "qpp.h"

int main() {
    using namespace qpp;
    ket psi = 00_q;
    cmat U = gt.CNOT * kron(gt.H, gt.Id2);
    ket result = U * psi; // we have the Bell state (|00> + |11>) / sqrt(2)

    std::cout << ">> We just produced the Bell state:\n";
    std::cout << disp(result) << '\n';

    // apply a bit flip on the second qubit
    result = apply(result, gt.X, {1}); // we produced (|01> + |10>) / sqrt(2)
    std::cout << ">> We produced the Bell state:\n";
    std::cout << disp(result) << '\n';

    // measure the first qubit in the X basis
    auto measured = measure(result, gt.H, {0});
    std::cout << ">> Measurement result: " << std::get<0>(measured) << '\n';
    std::cout << ">> Probabilities: ";
    std::cout << disp(std::get<1>(measured), ", ") << '\n';
    std::cout << ">> Resulting states:\n";
    for (auto&& it : std::get<2>(measured))
        std::cout << disp(it) << "\n\n";
}
```

A possible output is:

```text
>> We just produced the Bell state:
0.707107
       0
       0
0.707107
>> We produced the Bell state:
       0
0.707107
0.707107
       0
>> Measurement result: 0
>> Probabilities: [0.5, 0.5]
>> Resulting states:
0.707107
0.707107

-0.707107
 0.707107
```

In line 12 of Listing \[lst3\] we use the function `kron()` to create
the tensor product (Kronecker product) of the Hadamard gate on the first
qubit and identity on the second qubit, then we left-multiply it by the
Controlled-NOT gate. In line 13 we compute the result of the operation
$CNOT_{ab}(H\otimes I)|00\rangle$, which is the Bell state
$(|00\rangle + |11\rangle)/\sqrt{2}$. We display it in lines 15 and 16.

In line 19 we use the function `apply()` to apply the gate $X$ on the
second qubit[^2] of the previously produced Bell state. The function
`apply()` takes as its third parameter a list of subsystems, and in our
case `{1}` denotes the *second* subsystem, not the first. The function
`apply()`, as well as many other functions that we will encounter, have
a variety of useful overloads, see `doc/refman.pdf` for a detailed
library reference. In lines 20 and 21 we display the newly created Bell
state.

In line 24 we use the function `measure()` to perform a measurement of
the first qubit (subsystem `{0}`) in the $X$ basis. You may be confused
by the apparition of `gt.H`, however this overload of the function
`measure()` takes as its second parameter the measurement basis,
specified as the columns of a complex matrix. In our case, the
eigenvectors of the $X$ operator are just the columns of the Hadamard
matrix. As mentioned before, as all other library functions, `measure()`
returns by value, hence it does not modify its argument. The return of
`measure` is a tuple consisting of the measurement result, the outcome
probabilities, and the possible output states. Technically `measure()`
returns a tuple of 3 elements

```CPP
std::tuple<qpp::idx, std::vector<double>, std::vector<qpp::cmat>>
```

The first element represents the measurement result, the second the
possible output probabilities and the third the output output states.
Instead of using this long type definition, we use the new C++11 `auto`
keyword to define the type of the result `measured` of `measure()`. In
lines 25–30 we use the standard `std::get<>()` function to retrieve each
element of the tuple, then display the measurement result, the
probabilities and the resulting output states.

Quantum operations
------------------

In [`qpp/examples/quantum_operations.cpp`](https://github.com/vsoftco/qpp/blob/master/examples/quantum_operations.cpp) displayed below

```CPP
// Quantum operations
// Source: ./examples/quantum_operations.cpp
#include <iostream>
#include <vector>

#include "qpp.h"

int main() {
    using namespace qpp;
    cmat rho = st.pb00; // projector onto the Bell state (|00> + |11>) / sqrt(2)
    std::cout << ">> Initial state:\n";
    std::cout << disp(rho) << '\n';

    // partial transpose of first subsystem
    cmat rhoTA = ptranspose(rho, {0});
    std::cout << ">> Eigenvalues of the partial transpose "
              << "of Bell-0 state are:\n";
    std::cout << disp(transpose(hevals(rhoTA))) << '\n';

    std::cout << ">> Measurement channel with 2 Kraus operators:\n";
    std::vector<cmat> Ks{st.pz0, st.pz1}; // 2 Kraus operators
    std::cout << disp(Ks[0]) << "\nand\n" << disp(Ks[1]) << '\n';

    std::cout << ">> Superoperator matrix of the channel:\n";
    std::cout << disp(kraus2super(Ks)) << '\n';

    std::cout << ">> Choi matrix of the channel:\n";
    std::cout << disp(kraus2choi(Ks)) << '\n';

    // apply the channel onto the first subsystem
    cmat rhoOut = apply(rho, Ks, {0});
    std::cout << ">> After applying the measurement channel "
              << "on the first qubit:\n";
    std::cout << disp(rhoOut) << '\n';

    // take the partial trace over the second subsystem
    cmat rhoA = ptrace(rhoOut, {1});
    std::cout << ">> After partially tracing down the second subsystem:\n";
    std::cout << disp(rhoA) << '\n';

    // compute the von-Neumann entropy
    double ent = entropy(rhoA);
    std::cout << ">> Entropy: " << ent << '\n';
}
```

we introduce quantum operations: quantum channels,
as well as the partial trace and partial transpose operations.

The output of this program is:

```text
>> Initial state:
0.5   0   0   0.5
  0   0   0     0
  0   0   0     0
0.5   0   0   0.5
>> Eigenvalues of the partial transpose of Bell-0 state are:
-0.5   0.5   0.5   0.5
>> Measurement channel with 2 Kraus operators:
1   0
0   0
and
0   0
0   1
>> Superoperator matrix of the channel:
1   0   0   0
0   0   0   0
0   0   0   0
0   0   0   1
>> Choi matrix of the channel:
1   0   0   0
0   0   0   0
0   0   0   0
0   0   0   1
>> After applying the measurement channel on the first qubit:
0.5   0   0     0
  0   0   0     0
  0   0   0     0
  0   0   0   0.5
>> After partially tracing down the second subsystem:
0.5     0
  0   0.5
>> Entropy: 1
```

The example should by now be self-explanatory. In line 11 of
Listing \[lst4\] we define the input state `rho` as the projector onto
the Bell state $(|00\rangle + |11\rangle)/\sqrt{2}$, then display it in
lines 12 and 13.

In lines 16–19 we partially transpose the first qubit, then display the
eigenvalues of the resulting matrix `rhoTA`.

In lines 21–23 we define a quantum channel `Ks` consisting of two Kraus
operators: $|0\rangle\langle 0|$ and $|1\rangle\langle 1|$, then display
the latter. Note that [Quantum++](https://github.com/vsoftco/qpp) uses
the `std::vector<cmat>` container to store the Kraus operators and
define a quantum channel.

In lines 25–29 we display the superoperator matrix as well as the Choi
matrix of the channel `Ks`.

Next, in lines 32–35 we apply the channel `Ks` to the first qubit of the
input state `rho`, then display the output state `rhoOut`.

In lines 38–40 we take the partial trace of the output state `rhoOut`,
then display the resulting state `rhoA`.

Finally, in lines 43 and 44 we compute the von-Neumann entropy of the
resulting state and display it.

Timing
------

To facilitate simple timing tasks,
[Quantum++](https://github.com/vsoftco/qpp) provides a `Timer` class
that uses internally a `std::steady_clock`. The program 
[`qpp/examples/timing.cpp`](https://github.com/vsoftco/qpp/blob/master/examples/timing.cpp)
listed below demonstrate its usage.

```CPP
// Timing
// Source: ./examples/timing.cpp
#include <iomanip>
#include <iostream>
#include <vector>

#include "qpp.h"

int main() {
    using namespace qpp;
    std::cout << std::setprecision(8); // increase the default output precision

    // get the first codeword from Shor's [[9,1,3]] code
    ket c0 = codes.codeword(Codes::Type::NINE_QUBIT_SHOR, 0);

    Timer<> t;                           // declare and start a timer
    std::vector<idx> perm = randperm(9); // declare a random permutation
    ket c0perm = syspermute(c0, perm);   // permute the system
    t.toc();                             // stops the timer
    std::cout << ">> Permuting subsystems according to " << disp(perm, ", ");
    std::cout << "\n>> It took " << t << " seconds to permute the subsytems.\n";

    t.tic(); // restart the timer
    std::cout << ">> Inverse permutation: ";
    std::cout << disp(invperm(perm), ", ") << '\n';
    ket c0invperm = syspermute(c0perm, invperm(perm)); // permute again
    std::cout << ">> It took " << t.toc();
    std::cout << " seconds to un-permute the subsystems.\n";

    std::cout << ">> Norm difference: " << norm(c0invperm - c0) << '\n';
}
```

A possible output of this program is:

```text
>> Permuting subsystems according to [1, 0, 2, 3, 6, 7, 5, 8, 4]
>> It took 0.00016 seconds to permute the subsytems.
>> Inverse permutation: [1, 0, 2, 3, 8, 6, 4, 5, 7]
>> It took 8.4e-05 seconds to un-permute the subsystems.
>> Norm difference: 0
```

In line 12 of Listing \[lst5\] we change the default output precision
from 4 to 8 decimals after the delimiter.

In line 15 we use the `Codes` singleton `codes` to retrieve in `c0` the
first codeword of the Shor’s $[[9,1,3]]$ quantum error correcting code.

In line 17 we declare an instance `timer` of the class `Timer`. In
line 18 we declare a random permutation `perm` via the function
`randperm()`. In line 19 we permute the codeword according to the
permutation `perm` using the function `syspermute()` and store the
result . In line 20 we stop the timer. In line 21 we display the
permutation, using an overloaded form of the `disp()` manipulator for
C++ standard library containers. The latter takes a `std::string` as its
second parameter to specify the delimiter between the elements of the
container. In line 22 we display the elapsed time using the
`ostream operator<<()` operator overload for `Timer` objects.

Next, in line 24 we reset the timer, then display the inverse
permutation of `perm` in lines 25 and 26. In line 27 we permute the
already permuted state `c0perm` according to the inverse permutation of
`perm`, and store the result in `c0invperm`. In lines 28 and 29 we
display the elapsed time. Note that in line 28 we used directly
`t.toc()` in the stream insertion operator, since, for convenience, the
member function `Timer::toc()` returns a `const Timer&`.

Finally, in line 31, we verify that by permuting and permuting again
using the inverse permutation we recover the initial codeword, i.e. the
norm difference has to be zero.

Input/output
------------

We now introduce the input/output functions of
[Quantum++](https://github.com/vsoftco/qpp), as well as the input/output
interfacing with [MATLAB](http://www.mathworks.com/products/matlab/).
The program 
[qpp/examples/input_output.cpp](https://github.com/vsoftco/qpp/blob/master/examples/input_output.cpp) 
saves a matrix in both
[Quantum++](https://github.com/vsoftco/qpp) internal format as well as
in [MATLAB](http://www.mathworks.com/products/matlab/) format, then
loads it back and tests that the norm difference between the
saved/loaded matrix is zero. The code is displayed below.

```CPP
// Input/output
// Source: ./examples/input_output.cpp
#include <iostream>

#include "qpp.h"
#include "MATLAB/matlab.h" // must be explicitly included

int main() {
    using namespace qpp;
    // Quantum++ native input/output
    cmat rho = randrho(256);                 // an 8 qubit density operator
    save(rho, "rho.dat");                    // save it
    cmat loaded_rho = load<cmat>("rho.dat"); // load it back
    // display the difference in norm, should be 0
    std::cout << ">> Norm difference load/save: ";
    std::cout << norm(loaded_rho - rho) << '\n';

    // interfacing with MATLAB
    saveMATLAB(rho, "rho.mat", "rho", "w");
    loaded_rho = loadMATLAB<cmat>("rho.mat", "rho");
    // display the difference in norm, should be 0
    std::cout << ">> Norm difference MATLAB load/save: ";
    std::cout << norm(loaded_rho - rho) << '\n';
}
```

The output of this program is:

```text
>> Norm difference load/save: 0
>> Norm difference MATLAB load/save: 0
```

Note that in order to use the
[MATLAB](http://www.mathworks.com/products/matlab/) input/output
interface support, you need to explicitly include the header file
[`MATLAB/matlab.h`](https://github.com/vsoftco/qpp/blob/master/include/MATLAB/matlab.h), and you also need to have
[MATLAB](http://www.mathworks.com/products/matlab/) or
[MATLAB](http://www.mathworks.com/products/matlab/) compiler installed,
otherwise the program fails to compile. See the file [`qpp/README.md`](https://github.com/vsoftco/qpp/blob/master/README.md) for
extensive details about compiling with
[MATLAB](http://www.mathworks.com/products/matlab/) support.

Exceptions
----------

Most [Quantum++](https://github.com/vsoftco/qpp) functions throw
exceptions in the case of unrecoverable errors, such as out-of-range
input parameters, input/output errors etc. The exceptions are handled
via the class `Exception`, derived from [`std::exception`](http://en.cppreference.com/w/cpp/error/exception). The exception
types are hard-coded inside the strongly-typed enumeration (enum class)
`Exception::Type`. If you want to add more exceptions, augment the
enumeration `Exception::Type` and also modify accordingly the member
function `Exception::construct_exception_msg_()`, which constructs the
exception message displayed via the overridden virtual function
`Exception::what()`. Listing 
[`qpp/examples/exceptions.cpp`](https://github.com/vsoftco/qpp/blob/master/examples/exceptions.cpp)
displayed below illustrates the basics of exception handling in [Quantum++](https://github.com/vsoftco/qpp).

```CPP
// Exceptions
// Source: ./examples/exceptions.cpp
#include <exception>
#include <iostream>

#include "qpp.h"

int main() {
    using namespace qpp;
    cmat rho = randrho(16); // 4 qubits (subsystems)
    try {
        // the line below throws qpp::exception::SubsysMismatchDims
        double mInfo = qmutualinfo(rho, {0}, {4});
        std::cout << ">> Mutual information between first and last subsystem: ";
        std::cout << mInfo << '\n';
    } catch (const std::exception& e) {
        std::cout << ">> Exception caught: " << e.what() << '\n';
    }
}
```

The output of this program is:

```text
>> Exception caught: IN qpp::qmutualinfo(): Subsystems mismatch dimensions!
```

In line 11 of Listing \[lst7\] we define a random density matrix on four
qubits (dimension 16). In line 15, we compute the mutual information
between the first and the 5-th subsystem. Line 15 throws an exception of
type `qpp::exception::SubsysMismatchDim` exception, as there are only
four systems. We next catch the exception in line 19 via the
`std::exception` standard exception base class. We could have also used
the Quantum++ exception base class `qpp::exception::Exception`, however
using the `std::exception` allows the catching of other exceptions, not
just of the type `Exception`. Finally, in line 21 we display the
corresponding exception message.