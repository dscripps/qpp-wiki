Aliasing
--------

Aliasing occurs whenever the same [Eigen 3](http://eigen.tuxfamily.org/)
matrix/vector appears on both sides of the assignment operator, and
happens because of [Eigen 3](http://eigen.tuxfamily.org/)’s lazy
evaluation system. Examples that exhibit aliasing:

``` {numbers="none"}
mat = 2 * mat;
```

or

``` {numbers="none"}
mat = mat.transpose();
```

Aliasing *does not* occur in statements like

``` {numbers="none"}
mat = f(mat);
```

where `f()` returns by value. Aliasing produces in general unexpected
results, and should be avoided at all costs.

Whereas the first line produces aliasing, it is not dangerous, since the
assignment is done in a one-to-one manner, i.e. each element $(i,j)$ on
the left hand side of the assignment operator is solely a function of
the the *same* $(i,j)$ element on the right hand side, i.e.
$mat(i,j) = f(mat(i,j))$, $\forall i,j$. The problem appears whenever
coefficients are being combined and overlap, such as in the second
example, where $mat(i,j) = mat(j,i)$, $\forall i,j$. To avoid aliasing,
use the member function `eval()` to transform the right hand side object
into a temporary, such as

``` {numbers="none"}
mat = 2 * mat.eval();
```

In general, aliasing can not be detected at compile time, but can be
detected at runtime whenever the compile flag `EIGEN_NO_DEBUG` is not
set. [Quantum++](https://github.com/vsoftco/qpp) does not set this flag
in debug mode. I highly recommend to first compile your program in debug
mode to detect aliasing run-time assertions, as well as other possible
issues that may have escaped you, such as assigning to a matrix another
matrix of different dimension etc.

For more details about aliasing, see the official [Eigen
3](http://eigen.tuxfamily.org/) documentation at
<http://eigen.tuxfamily.org/dox/group__TopicAliasing.html>.

Type deduction via `auto`
-------------------------

Avoid the usage of `auto` when working with [Eigen
3](http://eigen.tuxfamily.org/) expressions, e.g. avoid writing code
like

``` {numbers="none"}
auto mat = A * B + C;
```

but write instead

``` {numbers="none"}
cmat mat = A * B + C;
```

or

``` {numbers="none"}
auto mat = (A * B + C).eval();
```

to force evaluation, as otherwise you may get unexpected results. The
“problem" lies in the [Eigen 3](http://eigen.tuxfamily.org/) lazy
evaluation system and reference binding, see e.g.
<http://stackoverflow.com/q/26705446/3093378> for more details. In
short, the reference to the internal data represented by the expression
`A * B + C` is dangling at the end of the `auto mat = A * B + C;`
statement.

Optimizations
-------------

Whenever testing your application, I recommend compiling in debug mode,
as [Eigen 3](http://eigen.tuxfamily.org/) run-time assertions can
provide extremely helpful feedback on potential issues. Whenever the
code is production-ready, you should *always* compile with optimization
flags turned on, such as `-O3` (for [g++](https://gcc.gnu.org/)) and
`-DEIGEN_NO_DEBUG`. You should also turn on the
[OpenMP](http://openmp.org/) (if available) multi-processing flag
(`-fopenmp` for [g++](https://gcc.gnu.org/)), as it enables
multi-core/multi-processing with shared memory. [Eigen
3](http://eigen.tuxfamily.org/) uses multi-processing when available,
e.g. in matrix multiplication.
[Quantum++](https://github.com/vsoftco/qpp) also uses multi-processing
in computationally-intensive functions.

Since most [Quantum++](https://github.com/vsoftco/qpp) functions return
by value, in assignments of the form

``` {numbers="none"}
mat = f(another_mat);
```

there is an additional copy assignment operator when assigning the
temporary returned by `f()` back to `mat`. As far as I know, this extra
copy operation is not elided. Unfortunately, [Eigen
3](http://eigen.tuxfamily.org/) does not yet support move semantics,
which would have got rid of this additional assignment via the
corresponding move assignment operator. If in the future [Eigen
3](http://eigen.tuxfamily.org/) will support move semantics, the
additional assignment operator will be “free", and you won’t have to
modify any existing code to enable the optimization; the [Eigen
3](http://eigen.tuxfamily.org/) move assignment operator should take
care of it for you.

Note that in a line of the form

``` {numbers="none"}
cmat mat = f(another_mat);
```

most compilers perform return value optimization (RVO), i.e. the
temporary on the right hand side is constructed directly inside the
object `mat`, the copy constructor being elided.

Extending Quantum++
-------------------

Most [Quantum++](https://github.com/vsoftco/qpp) operate on [Eigen
3](http://eigen.tuxfamily.org/) matrices/vectors, and return either a
matrix or a scalar. In principle, you may be tempted to write a new
function such as

``` {numbers="none"}
cmat f(const cmat& A){...}
```

The problem with the approach above is that [Eigen
3](http://eigen.tuxfamily.org/) uses *expression templates* as the type
of each expression, i.e. different expressions have in general different
types, see the official [Eigen 3](http://eigen.tuxfamily.org/)
documentation at
<http://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html> for
more details. The correct way to write a generic function that is
guaranteed to work with any matrix expression is to make your function
template and declare the input parameter as
`Eigen::MatrixBase<Derived>`, where `Derived` is the template parameter.
For example, the [Quantum++](https://github.com/vsoftco/qpp)
`transpose()` function is defined as

    template<typename Derived> 
    dyn_mat<typename Derived::Scalar> 
    transpose(const Eigen::MatrixBase<Derived>& A)
    {
        const dyn_mat<typename Derived::Scalar>& rA = A.derived();

        // check zero-size
        if (!internal::check_nonzero_size(rA))
            throw Exception("qpp::transpose()", Exception::Type::ZERO_SIZE);

        return rA.transpose();
    }

It takes an [Eigen 3](http://eigen.tuxfamily.org/) matrix expression,
line 3, and returns a dynamic matrix over the scalar field of the
expression, line 2. In line 5 we implicitly convert the input expression
`A` to a dynamic matrix `rA` over the same scalar field as the
expression, via binding to a `const` reference, therefore paying no
copying cost. We then use `rA` instead of the original expression `A` in
the rest of the function. Note that most of the time it is OK to use the
original expression, however there are some cases where you may get a
compile time error if the expression is not explicitly casted to a
matrix. For consistency, I use this reference binding trick in the code
of all [Quantum++](https://github.com/vsoftco/qpp) functions.

As you may have already seen,
[Quantum++](https://github.com/vsoftco/qpp) consists mainly of a
collection of functions and few classes. There is no complicated class
hierarchy, and you can regard the
[Quantum++](https://github.com/vsoftco/qpp) API as a medium-level API.
You may extend it to incorporate graphical input, e.g. use a graphical
library such as [Qt](http://qt-project.org/), or build a more
sophisticated library on top of it. I recommend to read the source code
and make yourself familiar with the library before deciding to extend
it. You should also check the complete reference manual
`./doc/refman.pdf` for an extensive documentation of all functions and
classes. I hope you find [Quantum++](https://github.com/vsoftco/qpp)
useful and wish you a happy usage!
